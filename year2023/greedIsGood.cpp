#include "year2023.h"

/*
"Жадность" — это игра в кости, в которую играют пятью шестигранными костями.
Игрок делает бросок, получая массив с пятью значениями шестигранных кубиков.

Подсчёт очков:_______________
Три единицы    => 1000 points
Три шестёрки   =>  600 points
Три пятёрки    =>  500 points
Три четвёрки   =>  400 points
Три тройки     =>  300 points
Три двойки     =>  200 points

Одна единица   =>  100 points
Одна пятёрка   =>   50 point
_____________________________

Один кубик может быть подсчитан только один раз в каждом броске.
Например, данная цифра «5» может учитываться только как часть тройки (составляющая 500 баллов) или как одна 50 баллов,
но не обе в одном броске.

Ваша миссия, состоит в том, чтобы посчитать очки в соответствии с этими правилами.

Примеры:
5 1 3 4 1   дадут 250 очков  :  50 (за 5) + 2 * 100 (за две единицы)
1 1 1 3 1   дадут 1100 очков : 1000 (за три единицы) + 100 (за единицу)
2 4 4 5 4   дадут 450 очков  :  400 (за три четвёрки) + 50 (за пятёрку)
*/

int score(const vector<int>& dice)
{
	int points = 0;

	for (int i = 0; i < dice.size(); i++)
	{
		if (dice[i] == 1)
		{
			points += 100; // Каждая единица нам даёт 100 очков.
		}
		else if (dice[i] == 5)
		{
			points += 50; // Каждая пятёрка нам даёт 50 очков.
		}

		// С помощью второго цикла проверим, сколько найдётся соответствий для текущего элемента в остальном массиве.
		int count = 1; // Отсчёт соответствий начинается заново каждую итерацию цикла.

		for (int j = i + 1; i < 3 && j < dice.size(); j++)
		{
			if (dice[i] == dice[j])
			{
				count++;
			}
		}

		if (count == 3) // Каждое третье совпадение с текущим элементом даёт нам:
		{
			if (dice[i] == 1)
			{
				points += 700; // +700 очков, если это единицы...
			}
			else if (dice[i] == 5)
			{
				points += 350; // +350 очков, если это пятёрки...
			}
			else
			{
				points += dice[i] * 100; // и 100 очков помноженных на значение текущего элемента, согласно условию задачи.
			}
		}
	}

	return points;
}

//Best practice:
/*
int score(const vector<int>& dice)
{
	unsigned cs[7] = {};
	for (auto d : dice)
		cs[d]++;
	return
		cs[1] / 3 * 1000 + cs[6] / 3 * 600 + cs[5] / 3 * 500 +
		cs[4] / 3 * 400 + cs[3] / 3 * 300 + cs[2] / 3 * 200 +
		cs[1] % 3 * 100 + cs[5] % 3 * 50;
}
*/